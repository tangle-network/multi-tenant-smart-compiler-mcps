{
  "/Move.toml": "[package]\nname = \"my_first_package\"\nedition = \"2024.beta\" # edition = \"legacy\" to use legacy (pre-2024) Move\n# license = \"\"           # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\n# authors = [\"...\"]      # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"John Snow (johnsnow@noemail.com)\"]\n\n[dependencies]\n\n# For remote import, use the `{ git = \"...\", subdir = \"...\", rev = \"...\" }`.\n# Revision can be a branch, a tag, and a commit hash.\n# MyRemotePackage = { git = \"https://some.remote/host.git\", subdir = \"remote/path\", rev = \"main\" }\n\n# For local dependencies use `local = path`. Path is relative to the package root\n# Local = { local = \"../path/to\" }\n\n# To resolve a version conflict and force a specific version for dependency\n# override use `override = true`\n# Override = { local = \"../conflicting/version\", override = true }\n\n[addresses]\nmy_first_package = \"0x0\"\n\n# Named addresses will be accessible in Move as `@name`. They're also exported:\n# for example, `std = \"0x1\"` is exported by the Standard Library.\n# alice = \"0xA11CE\"\n\n[dev-dependencies]\n# The dev-dependencies section allows overriding dependencies for `--test` and\n# `--dev` modes. You can introduce test-only dependencies here.\n# Local = { local = \"../path/to/dev-build\" }\n\n[dev-addresses]\n# The dev-addresses section allows overwriting named addresses for the `--test`\n# and `--dev` modes.\n# alice = \"0xB0B\"\n",
  "/sources/example.move": "module my_first_package::example;\n\nuse sui::object::{Self, UID};\nuse sui::transfer;\nuse sui::tx_context::{Self, TxContext};\n\npublic struct Sword has key, store {\n    id: UID,\n    magic: u64,\n    strength: u64,\n}\n\npublic struct Forge has key {\n    id: UID,\n    swords_created: u64,\n}\n\nfun init(ctx: &mut TxContext) {\n    let admin = Forge {\n        id: object::new(ctx),\n        swords_created: 0,\n    };\n\n    transfer::transfer(admin, ctx.sender());\n}\n\npublic fun magic(self: &Sword): u64 {\n    self.magic\n}\n\npublic fun strength(self: &Sword): u64 {\n    self.strength\n}\n\npublic fun swords_created(self: &Forge): u64 {\n    self.swords_created\n}\n\npublic fun sword_create(magic: u64, strength: u64, ctx: &mut TxContext): Sword {\n    // Create a sword\n    Sword {\n        id: object::new(ctx),\n        magic: magic,\n        strength: strength,\n    }\n}\n\n/// Constructor for creating swords\npublic fun new_sword(forge: &mut Forge, magic: u64, strength: u64, ctx: &mut TxContext): Sword {\n    forge.swords_created = forge.swords_created + 1;\n    Sword {\n        id: object::new(ctx),\n        magic: magic,\n        strength: strength,\n    }\n}\n\n#[test]\nfun test_sword_create() {\n    // Create a dummy TxContext for testing\n    let mut ctx = tx_context::dummy();\n\n    // Create a sword\n    let sword = Sword {\n        id: object::new(&mut ctx),\n        magic: 42,\n        strength: 7,\n    };\n\n    // Check if accessor functions return correct values\n    assert!(sword.magic() == 42 && sword.strength() == 7, 1);\n\n    // Create a dummy address and transfer the sword\n    let dummy_address = @0xCAFE;\n    transfer::public_transfer(sword, dummy_address);\n}\n\n#[test]\nfun test_sword_transactions() {\n    use sui::test_scenario;\n\n    // Create test addresses representing users\n    let initial_owner = @0xCAFE;\n    let final_owner = @0xFACE;\n\n    // First transaction executed by initial owner to create the sword\n    let mut scenario = test_scenario::begin(initial_owner);\n    {\n        // Create the sword and transfer it to the initial owner\n        let sword = sword_create(42, 7, scenario.ctx());\n        transfer::public_transfer(sword, initial_owner);\n    };\n\n    // Second transaction executed by the initial sword owner\n    scenario.next_tx(initial_owner);\n    {\n        // Extract the sword owned by the initial owner\n        let sword = scenario.take_from_sender<Sword>();\n        // Transfer the sword to the final owner\n        transfer::public_transfer(sword, final_owner);\n    };\n\n    // Third transaction executed by the final sword owner\n    scenario.next_tx(final_owner);\n    {\n        // Extract the sword owned by the final owner\n        let sword = scenario.take_from_sender<Sword>();\n        // Verify that the sword has expected properties\n        assert!(sword.magic() == 42 && sword.strength() == 7, 1);\n        // Return the sword to the object pool (it cannot be simply \"dropped\")\n        scenario.return_to_sender(sword)\n    };\n    scenario.end();\n}\n\n#[test]\nfun test_module_init() {\n    use sui::test_scenario;\n\n    // Create test addresses representing users\n    let admin = @0xAD;\n    let initial_owner = @0xCAFE;\n\n    // First transaction to emulate module initialization\n    let mut scenario = test_scenario::begin(admin);\n    {\n        init(scenario.ctx());\n    };\n\n    // Second transaction to check if the forge has been created\n    // and has initial value of zero swords created\n    scenario.next_tx(admin);\n    {\n        // Extract the Forge object\n        let forge = scenario.take_from_sender<Forge>();\n        // Verify number of created swords\n        assert!(forge.swords_created() == 0, 1);\n        // Return the Forge object to the object pool\n        scenario.return_to_sender(forge);\n    };\n\n    // Third transaction executed by admin to create the sword\n    scenario.next_tx(admin);\n    {\n        let mut forge = scenario.take_from_sender<Forge>();\n        // Create the sword and transfer it to the initial owner\n        let sword = forge.new_sword(42, 7, scenario.ctx());\n        transfer::public_transfer(sword, initial_owner);\n        scenario.return_to_sender(forge);\n    };\n    scenario.end();\n}\n"
}