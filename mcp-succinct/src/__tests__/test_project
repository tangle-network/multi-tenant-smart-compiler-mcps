{
  "/.env": "# Proof modes are `mock`, `cpu`, `cuda` and `network`.\n# `mock` is for generating mock proofs locally.\n# `cpu` is for generating proofs locally using the CPU.\n# `cuda` is for generating proofs locally using the GPU.\n# `network` is for generating proofs using the Succinct Prover Network.\nSP1_PROVER=cpu\n\n# To use the Succinct Prover Network, set the private key of the account you want to use for requesting proofs.\n# Set up a new account here: https://docs.succinct.xyz/docs/network/developers/key-setup.\nNETWORK_PRIVATE_KEY=",
  "/.gitignore": "# Cargo build\n**/target\n\n# Cargo config\n.cargo\n\n# Profile-guided optimization\n/tmp\npgo-data.profdata\n\n# MacOS nuisances\n.DS_Store\n\n# Proofs\n**/proof-with-pis.json\n**/proof-with-io.json\n\n# Env\n.env",
  "/.gitmodules": "[submodule \"contracts/lib/forge-std\"]\n\tpath = contracts/lib/forge-std\n\turl = https://github.com/foundry-rs/forge-std\n\ttag = v1.8.2\n[submodule \"contracts/lib/sp1-contracts\"]\n\tpath = contracts/lib/sp1-contracts\n\turl = https://github.com/succinctlabs/sp1-contracts\n\ttag = v3.0.0\n",
  "/Cargo.toml": "[workspace]\nmembers = [\n    \"lib\",\n    \"program\",\n    \"script\",\n]\nresolver = \"2\"\n\n[workspace.dependencies]\nalloy-sol-types = \"1.0\"",
  "/contracts/.gitignore": "# Compiler files\ncache/\nout/\n\n# Ignores development broadcast logs\n/broadcast\n/broadcast/*/11155111/\n/broadcast/*/31337/\n/broadcast/**/dry-run/\n\n# Docs\ndocs/\n\n# Dotenv file\n.env\n",
  "/contracts/foundry.toml": "[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\nfs_permissions = [{ access = \"read-write\", path = \"./\" }]\n\n# See more config options https://github.com/foundry-rs/foundry/blob/master/crates/config/README.md#all-options\n",
  "/contracts/remappings.txt": "@sp1-contracts/=./lib/sp1-contracts/contracts/src/",
  "/contracts/src/Fibonacci.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ISP1Verifier} from \"@sp1-contracts/ISP1Verifier.sol\";\n\nstruct PublicValuesStruct {\n    uint32 n;\n    uint32 a;\n    uint32 b;\n}\n\n/// @title Fibonacci.\n/// @author Succinct Labs\n/// @notice This contract implements a simple example of verifying the proof of a computing a\n///         fibonacci number.\ncontract Fibonacci {\n    /// @notice The address of the SP1 verifier contract.\n    /// @dev This can either be a specific SP1Verifier for a specific version, or the\n    ///      SP1VerifierGateway which can be used to verify proofs for any version of SP1.\n    ///      For the list of supported verifiers on each chain, see:\n    ///      https://github.com/succinctlabs/sp1-contracts/tree/main/contracts/deployments\n    address public verifier;\n\n    /// @notice The verification key for the fibonacci program.\n    bytes32 public fibonacciProgramVKey;\n\n    constructor(address _verifier, bytes32 _fibonacciProgramVKey) {\n        verifier = _verifier;\n        fibonacciProgramVKey = _fibonacciProgramVKey;\n    }\n\n    /// @notice The entrypoint for verifying the proof of a fibonacci number.\n    /// @param _proofBytes The encoded proof.\n    /// @param _publicValues The encoded public values.\n    function verifyFibonacciProof(bytes calldata _publicValues, bytes calldata _proofBytes)\n        public\n        view\n        returns (uint32, uint32, uint32)\n    {\n        ISP1Verifier(verifier).verifyProof(fibonacciProgramVKey, _publicValues, _proofBytes);\n        PublicValuesStruct memory publicValues = abi.decode(_publicValues, (PublicValuesStruct));\n        return (publicValues.n, publicValues.a, publicValues.b);\n    }\n}\n",
  "/contracts/src/fixtures/groth16-fixture.json": "{\n  \"a\": 6765,\n  \"b\": 10946,\n  \"n\": 20,\n  \"vkey\": \"0x00b51cef3572d1a49ae7f4a332221cab31cdb72b131dbf28fb6ab26e15458fe2\",\n  \"publicValues\": \"0x00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000001a6d0000000000000000000000000000000000000000000000000000000000002ac2\",\n  \"proof\": \"0x11b6a09d07727e8889e440a3a4fe6b3cc7e438d232daa177c762d3267ada247e165b06ca1beaf42fbaaa7676caf3dd978af6c1b7b64968f67f41e3d356790a09337566d81122aa6904fd105ff2a499c1f3264a3f55e740cda6521be1877225f4073f7a4a22fe10987f12d67a145738de4e301bb8e37347556bead5bb003ce32653ffae5a281be092e26c9d16eb569b3592eb766b0197fe05d359952a05958b2596239f061333369ab1d6576f80e965d0e3d8f1d3a74722e794e72199c3dee91bff8f3a5e087ac3fac78f5372befa133b94764b43c4c88ee4f3fc0495e52c74ad5a6d2c18008e6740d0aad32976971c95db159fb37d4f8428d7c5abe658a58d516acd664c\"\n}",
  "/contracts/src/fixtures/plonk-fixture.json": "{\n  \"a\": 6765,\n  \"b\": 10946,\n  \"n\": 20,\n  \"vkey\": \"0x005aa1cbc05f992604b4f375159054d79b76501cf214b1fec6724ea14eceaf78\",\n  \"publicValues\": \"0x00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000001a6d0000000000000000000000000000000000000000000000000000000000002ac2\",\n  \"proof\": \"0x1b34fe110b653a5bb2e727aacca6d4c9de41249fbd7586b9aa02af98399a3b3fd1666cec0c8473bae000e399aecaab29ecd01dcf66e08e638a7a7bae517ef9ed22be23df12c942a19b734fba23b60c1bbd9abca4f98c56dc118a0fc872ae921b54438e25185909e44fd21ab07cebba1de255741b72e8bad0620f05aebad4f765b1cbba112b4379c851beaac58afb53b98ff31dc9292c0163fdac2068608f197ff0be1c050857edec30d56a0373109031afc35e54b0b6383ee7944c8e3f1d08040fc0f5721fb16d8af362b7aff5855d2f6c4a843003a7b8020728114de8e4ef6dedbd532b1f7e65dbf48e8cc592cf8163f5de468e24e904d67b7ae3f58f7edc14fc38a60317b175cd23772ca939ffd13e9d7390cb4c811384d746fa874d4a84117c25c3ab2e124b51764997fefd97605bdfcf60f634bd0d3f47efb8d68ac077b8cac612bb15e2d52dc1662680acd46432e3415dbc936673a0060164f80d2a55d6e6a0eec709f763b91500f52ae86229b6f155aa7aa4a6350373b459027d959fbc8eeabc2d04a1e18f91b62d4094a6279def15868b9f01ed81be16b65e607f7eeb938c1018276c666be3300a1de112fbf3e3ebdf49c9daffab4711a11fecca183830639bbb1bfc81381e005f2c1d7702b2cc579719a32a2e8b8144cded8f19edb24ad709a01a49867454a0e9fe6253dbb04b4fd9484b2a2fa10fa974ff327b93ccf6f71a61061c2fd03794cb3badac3326b32467122480cf2810135832b89f8891248ff1c8035256d4e18515e1986d0995e6d945b02e88cace743fe19b86e7ac366c8448fb1dee3630fb6f57be5abded070ed4f04af597886e4d8f5188bcfb1d9fbca9f45b2223d5821917f386acf5ce74098e52f971257b5ad06039311e85f2bf4d3f6a7f300548634ba8c77666ad320f998cf42e6efa3fb84571959d055b394a7b9ede590ce87fda92632f6ece014fb9bd9b3ea3a919fc7139bc59003fa9f33a4342f46e2ca3d09e3d10af3d06906af1fea935bb06143d7525daa6a0cd5352d098d9af7c196d44286c029bf773f5dd8bcee23b60c44c2f7632224b880d4b856a9aaa0e832e2be26a5eb31a4f3697fdac727722eb76da934054937d29f44a01959fd571332a58e27cc753247c57817b338e30397fecff0fe609f6dae12cd54aae72a55ce60d46b7bb14ceba9b0e69f35be38547f7a3f71dbaea85459449daa1353f338fcf\"\n}",
  "/contracts/test/Fibonacci.t.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {stdJson} from \"forge-std/StdJson.sol\";\nimport {Fibonacci} from \"../src/Fibonacci.sol\";\nimport {SP1VerifierGateway} from \"@sp1-contracts/SP1VerifierGateway.sol\";\n\nstruct SP1ProofFixtureJson {\n    uint32 a;\n    uint32 b;\n    uint32 n;\n    bytes proof;\n    bytes publicValues;\n    bytes32 vkey;\n}\n\ncontract FibonacciGroth16Test is Test {\n    using stdJson for string;\n\n    address verifier;\n    Fibonacci public fibonacci;\n\n    function loadFixture() public view returns (SP1ProofFixtureJson memory) {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/src/fixtures/groth16-fixture.json\");\n        string memory json = vm.readFile(path);\n        bytes memory jsonBytes = json.parseRaw(\".\");\n        return abi.decode(jsonBytes, (SP1ProofFixtureJson));\n    }\n\n    function setUp() public {\n        SP1ProofFixtureJson memory fixture = loadFixture();\n\n        verifier = address(new SP1VerifierGateway(address(1)));\n        fibonacci = new Fibonacci(verifier, fixture.vkey);\n    }\n\n    function test_ValidFibonacciProof() public {\n        SP1ProofFixtureJson memory fixture = loadFixture();\n\n        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));\n\n        (uint32 n, uint32 a, uint32 b) = fibonacci.verifyFibonacciProof(fixture.publicValues, fixture.proof);\n        assert(n == fixture.n);\n        assert(a == fixture.a);\n        assert(b == fixture.b);\n    }\n\n    function testRevert_InvalidFibonacciProof() public {\n        vm.expectRevert();\n\n        SP1ProofFixtureJson memory fixture = loadFixture();\n\n        // Create a fake proof.\n        bytes memory fakeProof = new bytes(fixture.proof.length);\n\n        fibonacci.verifyFibonacciProof(fixture.publicValues, fakeProof);\n    }\n}\n\n\ncontract FibonacciPlonkTest is Test {\n    using stdJson for string;\n\n    address verifier;\n    Fibonacci public fibonacci;\n\n    function loadFixture() public view returns (SP1ProofFixtureJson memory) {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/src/fixtures/plonk-fixture.json\");\n        string memory json = vm.readFile(path);\n        bytes memory jsonBytes = json.parseRaw(\".\");\n        return abi.decode(jsonBytes, (SP1ProofFixtureJson));\n    }\n\n    function setUp() public {\n        SP1ProofFixtureJson memory fixture = loadFixture();\n\n        verifier = address(new SP1VerifierGateway(address(1)));\n        fibonacci = new Fibonacci(verifier, fixture.vkey);\n    }\n\n    function test_ValidFibonacciProof() public {\n        SP1ProofFixtureJson memory fixture = loadFixture();\n\n        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));\n\n        (uint32 n, uint32 a, uint32 b) = fibonacci.verifyFibonacciProof(fixture.publicValues, fixture.proof);\n        assert(n == fixture.n);\n        assert(a == fixture.a);\n        assert(b == fixture.b);\n    }\n\n    function testRevert_InvalidFibonacciProof() public {\n        vm.expectRevert();\n\n        SP1ProofFixtureJson memory fixture = loadFixture();\n\n        // Create a fake proof.\n        bytes memory fakeProof = new bytes(fixture.proof.length);\n\n        fibonacci.verifyFibonacciProof(fixture.publicValues, fakeProof);\n    }\n}\n",
  "/lib/Cargo.toml": "[package]\nname = \"fibonacci-lib\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nalloy-sol-types = { workspace = true }\n",
  "/lib/src/lib.rs": "use alloy_sol_types::sol;\n\nsol! {\n    /// The public values encoded as a struct that can be easily deserialized inside Solidity.\n    struct PublicValuesStruct {\n        uint32 n;\n        uint32 a;\n        uint32 b;\n    }\n}\n\n/// Compute the n'th fibonacci number (wrapping around on overflows), using normal Rust code.\npub fn fibonacci(n: u32) -> (u32, u32) {\n    let mut a = 0u32;\n    let mut b = 1u32;\n    for _ in 0..n {\n        let c = a.wrapping_add(b);\n        a = b;\n        b = c;\n    }\n    (a, b)\n}\n",
  "/program/Cargo.toml": "[package]\nversion = \"0.1.0\"\nname = \"fibonacci-program\"\nedition = \"2021\"\n\n[dependencies]\nalloy-sol-types = { workspace = true }\nsp1-zkvm = \"5.0.0\"\nfibonacci-lib = { path = \"../lib\" }\n",
  "/program/src/main.rs": "//! A simple program that takes a number `n` as input, and writes the `n-1`th and `n`th fibonacci\n//! number as an output.\n\n// These two lines are necessary for the program to properly compile.\n//\n// Under the hood, we wrap your main function with some extra code so that it behaves properly\n// inside the zkVM.\n#![no_main]\nsp1_zkvm::entrypoint!(main);\n\nuse alloy_sol_types::SolType;\nuse fibonacci_lib::{fibonacci, PublicValuesStruct};\n\npub fn main() {\n    // Read an input to the program.\n    //\n    // Behind the scenes, this compiles down to a custom system call which handles reading inputs\n    // from the prover.\n    let n = sp1_zkvm::io::read::<u32>();\n\n    // Compute the n'th fibonacci number using a function from the workspace lib crate.\n    let (a, b) = fibonacci(n);\n\n    // Encode the public values of the program.\n    let bytes = PublicValuesStruct::abi_encode(&PublicValuesStruct { n, a, b });\n\n    // Commit to the public values of the program. The final proof will have a commitment to all the\n    // bytes that were committed to.\n    sp1_zkvm::io::commit_slice(&bytes);\n}\n",
  "/rust-toolchain": "[toolchain]\nchannel = \"stable\"\ncomponents = [\"llvm-tools\", \"rustc-dev\"]",
  "/script/Cargo.toml": "[package]\nversion = \"0.1.0\"\nname = \"fibonacci-script\"\nedition = \"2021\"\ndefault-run = \"fibonacci\"\n\n[[bin]]\nname = \"fibonacci\"\npath = \"src/bin/main.rs\"\n\n[[bin]]\nname = \"evm\"\npath = \"src/bin/evm.rs\"\n\n[[bin]]\nname = \"vkey\"\npath = \"src/bin/vkey.rs\"\n\n[dependencies]\nsp1-sdk = \"5.0.0\"\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\nserde = { version = \"1.0.200\", default-features = false, features = [\"derive\"] }\nclap = { version = \"4.0\", features = [\"derive\", \"env\"] }\ntracing = \"0.1.40\"\nhex = \"0.4.3\"\nalloy-sol-types = { workspace = true }\nfibonacci-lib = { path = \"../lib\" }\ndotenv = \"0.15.0\"\n\n[build-dependencies]\nsp1-build = \"5.0.0\"\n",
  "/script/build.rs": "use sp1_build::build_program_with_args;\n\nfn main() {\n    build_program_with_args(\"../program\", Default::default())\n}\n",
  "/script/src/bin/evm.rs": "//! An end-to-end example of using the SP1 SDK to generate a proof of a program that can have an\n//! EVM-Compatible proof generated which can be verified onchain.\n//!\n//! You can run this script using the following command:\n//! ```shell\n//! RUST_LOG=info cargo run --release --bin evm -- --system groth16\n//! ```\n//! or\n//! ```shell\n//! RUST_LOG=info cargo run --release --bin evm -- --system plonk\n//! ```\n\nuse alloy_sol_types::SolType;\nuse clap::{Parser, ValueEnum};\nuse fibonacci_lib::PublicValuesStruct;\nuse serde::{Deserialize, Serialize};\nuse sp1_sdk::{\n    include_elf, HashableKey, ProverClient, SP1ProofWithPublicValues, SP1Stdin, SP1VerifyingKey,\n};\nuse std::path::PathBuf;\n\n/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.\npub const FIBONACCI_ELF: &[u8] = include_elf!(\"fibonacci-program\");\n\n/// The arguments for the EVM command.\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct EVMArgs {\n    #[arg(long, default_value = \"20\")]\n    n: u32,\n    #[arg(long, value_enum, default_value = \"groth16\")]\n    system: ProofSystem,\n}\n\n/// Enum representing the available proof systems\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum, Debug)]\nenum ProofSystem {\n    Plonk,\n    Groth16,\n}\n\n/// A fixture that can be used to test the verification of SP1 zkVM proofs inside Solidity.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct SP1FibonacciProofFixture {\n    a: u32,\n    b: u32,\n    n: u32,\n    vkey: String,\n    public_values: String,\n    proof: String,\n}\n\nfn main() {\n    // Setup the logger.\n    sp1_sdk::utils::setup_logger();\n\n    // Parse the command line arguments.\n    let args = EVMArgs::parse();\n\n    // Setup the prover client.\n    let client = ProverClient::from_env();\n\n    // Setup the program.\n    let (pk, vk) = client.setup(FIBONACCI_ELF);\n\n    // Setup the inputs.\n    let mut stdin = SP1Stdin::new();\n    stdin.write(&args.n);\n\n    println!(\"n: {}\", args.n);\n    println!(\"Proof System: {:?}\", args.system);\n\n    // Generate the proof based on the selected proof system.\n    let proof = match args.system {\n        ProofSystem::Plonk => client.prove(&pk, &stdin).plonk().run(),\n        ProofSystem::Groth16 => client.prove(&pk, &stdin).groth16().run(),\n    }\n    .expect(\"failed to generate proof\");\n\n    create_proof_fixture(&proof, &vk, args.system);\n}\n\n/// Create a fixture for the given proof.\nfn create_proof_fixture(\n    proof: &SP1ProofWithPublicValues,\n    vk: &SP1VerifyingKey,\n    system: ProofSystem,\n) {\n    // Deserialize the public values.\n    let bytes = proof.public_values.as_slice();\n    let PublicValuesStruct { n, a, b } = PublicValuesStruct::abi_decode(bytes).unwrap();\n\n    // Create the testing fixture so we can test things end-to-end.\n    let fixture = SP1FibonacciProofFixture {\n        a,\n        b,\n        n,\n        vkey: vk.bytes32().to_string(),\n        public_values: format!(\"0x{}\", hex::encode(bytes)),\n        proof: format!(\"0x{}\", hex::encode(proof.bytes())),\n    };\n\n    // The verification key is used to verify that the proof corresponds to the execution of the\n    // program on the given input.\n    //\n    // Note that the verification key stays the same regardless of the input.\n    println!(\"Verification Key: {}\", fixture.vkey);\n\n    // The public values are the values which are publicly committed to by the zkVM.\n    //\n    // If you need to expose the inputs or outputs of your program, you should commit them in\n    // the public values.\n    println!(\"Public Values: {}\", fixture.public_values);\n\n    // The proof proves to the verifier that the program was executed with some inputs that led to\n    // the give public values.\n    println!(\"Proof Bytes: {}\", fixture.proof);\n\n    // Save the fixture to a file.\n    let fixture_path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"../contracts/src/fixtures\");\n    std::fs::create_dir_all(&fixture_path).expect(\"failed to create fixture path\");\n    std::fs::write(\n        fixture_path.join(format!(\"{:?}-fixture.json\", system).to_lowercase()),\n        serde_json::to_string_pretty(&fixture).unwrap(),\n    )\n    .expect(\"failed to write fixture\");\n}\n",
  "/script/src/bin/main.rs": "//! An end-to-end example of using the SP1 SDK to generate a proof of a program that can be executed\n//! or have a core proof generated.\n//!\n//! You can run this script using the following command:\n//! ```shell\n//! RUST_LOG=info cargo run --release -- --execute\n//! ```\n//! or\n//! ```shell\n//! RUST_LOG=info cargo run --release -- --prove\n//! ```\n\nuse alloy_sol_types::SolType;\nuse clap::Parser;\nuse fibonacci_lib::PublicValuesStruct;\nuse sp1_sdk::{include_elf, ProverClient, SP1Stdin};\n\n/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.\npub const FIBONACCI_ELF: &[u8] = include_elf!(\"fibonacci-program\");\n\n/// The arguments for the command.\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    #[arg(long)]\n    execute: bool,\n\n    #[arg(long)]\n    prove: bool,\n\n    #[arg(long, default_value = \"20\")]\n    n: u32,\n}\n\nfn main() {\n    // Setup the logger.\n    sp1_sdk::utils::setup_logger();\n    dotenv::dotenv().ok();\n\n    // Parse the command line arguments.\n    let args = Args::parse();\n\n    if args.execute == args.prove {\n        eprintln!(\"Error: You must specify either --execute or --prove\");\n        std::process::exit(1);\n    }\n\n    // Setup the prover client.\n    let client = ProverClient::from_env();\n\n    // Setup the inputs.\n    let mut stdin = SP1Stdin::new();\n    stdin.write(&args.n);\n\n    println!(\"n: {}\", args.n);\n\n    if args.execute {\n        // Execute the program\n        let (output, report) = client.execute(FIBONACCI_ELF, &stdin).run().unwrap();\n        println!(\"Program executed successfully.\");\n\n        // Read the output.\n        let decoded = PublicValuesStruct::abi_decode(output.as_slice()).unwrap();\n        let PublicValuesStruct { n, a, b } = decoded;\n        println!(\"n: {}\", n);\n        println!(\"a: {}\", a);\n        println!(\"b: {}\", b);\n\n        let (expected_a, expected_b) = fibonacci_lib::fibonacci(n);\n        assert_eq!(a, expected_a);\n        assert_eq!(b, expected_b);\n        println!(\"Values are correct!\");\n\n        // Record the number of cycles executed.\n        println!(\"Number of cycles: {}\", report.total_instruction_count());\n    } else {\n        // Setup the program for proving.\n        let (pk, vk) = client.setup(FIBONACCI_ELF);\n\n        // Generate the proof\n        let proof = client\n            .prove(&pk, &stdin)\n            .run()\n            .expect(\"failed to generate proof\");\n\n        println!(\"Successfully generated proof!\");\n\n        // Verify the proof.\n        client.verify(&proof, &vk).expect(\"failed to verify proof\");\n        println!(\"Successfully verified proof!\");\n    }\n}\n",
  "/script/src/bin/vkey.rs": "use sp1_sdk::{include_elf, HashableKey, Prover, ProverClient};\n\n/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.\npub const FIBONACCI_ELF: &[u8] = include_elf!(\"fibonacci-program\");\n\nfn main() {\n    let prover = ProverClient::builder().cpu().build();\n    let (_, vk) = prover.setup(FIBONACCI_ELF);\n    println!(\"{}\", vk.bytes32());\n}"
}
