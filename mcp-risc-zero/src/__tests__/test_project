{
  "/.gitignore": ".DS_Store\nCargo.lock\nmethods/guest/Cargo.lock\ntarget/\n",
  "/Cargo.toml": "[workspace]\nresolver = \"2\"\nmembers = [\"host\", \"methods\"]\n\n# Always optimize; building and running the guest takes much longer without optimization.\n[profile.dev]\nopt-level = 3\n\n[profile.release]\ndebug = 1\nlto = true\n",
  "/host/Cargo.toml": "[package]\nname = \"host\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nmethods = { path = \"../methods\" }\nrisc0-zkvm = { version = \"^2.1.0\" }\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\nserde = \"1.0\"\n",
  "/host/src/main.rs": "// These constants represent the RISC-V ELF and the image ID generated by risc0-build.\n// The ELF is used for proving and the ID is used for verification.\nuse methods::{\n    HELLO_WORLD_METHODS_ELF, HELLO_WORLD_METHODS_ID\n};\nuse risc0_zkvm::{default_prover, ExecutorEnv};\n\nfn main() {\n    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`\n    tracing_subscriber::fmt()\n        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())\n        .init();\n\n    // An executor environment describes the configurations for the zkVM\n    // including program inputs.\n    // A default ExecutorEnv can be created like so:\n    // `let env = ExecutorEnv::builder().build().unwrap();`\n    // However, this `env` does not have any inputs.\n    //\n    // To add guest input to the executor environment, use\n    // ExecutorEnvBuilder::write().\n    // To access this method, you'll need to use ExecutorEnv::builder(), which\n    // creates an ExecutorEnvBuilder. When you're done adding input, call\n    // ExecutorEnvBuilder::build().\n\n    // For example:\n    let input: u32 = 15 * u32::pow(2, 27) + 1;\n    let env = ExecutorEnv::builder()\n        .write(&input)\n        .unwrap()\n        .build()\n        .unwrap();\n\n    // Obtain the default prover.\n    let prover = default_prover();\n\n    // Proof information by proving the specified ELF binary.\n    // This struct contains the receipt along with statistics about execution of the guest\n    let prove_info = prover\n        .prove(env, HELLO_WORLD_METHODS_ELF)\n        .unwrap();\n\n    // extract the receipt.\n    let receipt = prove_info.receipt;\n\n    // TODO: Implement code for retrieving receipt journal here.\n\n    // For example:\n    let _output: u32 = receipt.journal.decode().unwrap();\n\n    // The receipt was verified at the end of proving, but the below code is an\n    // example of how someone else could verify this receipt.\n    receipt\n        .verify(HELLO_WORLD_METHODS_ID)\n        .unwrap();\n}\n",
  "/methods/Cargo.toml": "[package]\nname = \"methods\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[build-dependencies]\nrisc0-build = { version = \"^2.1.2\" }\n\n[package.metadata.risc0]\nmethods = [\"guest\"]\n",
  "/methods/build.rs": "fn main() {\n    risc0_build::embed_methods();\n}\n",
  "/methods/guest/Cargo.toml": "[package]\nname = \"hello_world_methods\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[workspace]\n\n[dependencies]\nrisc0-zkvm = { version = \"^2.1.0\", default-features = false, features = ['std'] }\n",
  "/methods/guest/src/main.rs": "use risc0_zkvm::guest::env;\n\nfn main() {\n    // TODO: Implement your guest code here\n\n    // read the input\n    let input: u32 = env::read();\n\n    // TODO: do something with the input\n\n    // write public output to the journal\n    env::commit(&input);\n}\n",
  "/methods/src/lib.rs": "include!(concat!(env!(\"OUT_DIR\"), \"/methods.rs\"));\n",
  "/rust-toolchain.toml": "[toolchain]\nchannel = \"stable\"\ncomponents = [\"rustfmt\", \"rust-src\"]\nprofile = \"minimal\"\n"
}